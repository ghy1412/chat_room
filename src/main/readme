//使用quickStart

//MD5加密
//注册用户:  在服务端实现,需要网络
//注册成功返回登陆界面, 连接断掉 --> 简化 现在放在客户端


//
dao : 数据库
service : 处理业务

1.加载驱动 --- Thread    1.加载数据源(已经创建好的数据库连接) - 类比线程池
Class.forName("")
2.获取连接
3.使用完销毁             3.使用完不销毁   优点:1.降低资源消耗 2.提高响应速率 3.方便管理

数据源 :
最古老的数据源 c3p0数据源 性能低

druid 拽~ 阿里数据源

Hakari    spring的默认数据源


JDBC :基于数据源


1.加载数据源
2.获取连接 Connection
3.执行SQL
4.关闭资源
通过继承.有重复的封装在BasedDao

查询类SQL
  select : executeQuery
  PreparedStatement
  ResultSet

更新类SQL
  insert/update/delete
  PreparedStatement

  //页面

JPanel  - 盘子 存放各类组件的基础容器

JLabel  - 标签  图片也是标签
JTextField - 输入框
JButton - 按钮
JOptionPanel - 提示框(静态方法)

JScrollPane 滚动条

farm.size(400,400); 删除 pork
-成功
-失败
ServerSocket  服务端
   -accept(): 返回客户端的Socket
Socket 客户端

//点击登录
1.发送验证码  验证用户名  密码
-不成功 提示  继续当前页面

-成功  和服务器连接
? 但服务器怎么知道是你   -你的qq号

//现在还是存在一个问题 我可以重复登录 / 那么想要解决这个问题 或许可以从 服务器端的Map集合入手
      -比如说名字已经在服务器端的Map集合里面了!!!!  那我就可以不去服务端查找 直接告诉你 你还想一号登两次?


/////这是服务器和客户端要做的事情哈

服务端
1.保存新用户的上线信息
2.将当前的所有用户 发送给新用户的好友列表
3.服务器给新用户的所有好友 发送上线提醒

客户端
1.与服务器建立连接, 将自己的用户名与Socket保存到服务端缓存
2.读取服务端的所有在线好友信息
3.既然要接收 , 那么新建一个后台线程不断读取服务端发送来的信息



传递消息  使用 json字符串
 - {"key":"value",...}
 第三方工具 转换 json序列化概念  str -> Object :json的反序列化  Object -> str :json的序列化
  这和以前的序列化功不一样 以前的 序列化是把 对象变为流的形式 Object...()方法之类的
  //你想转换 首先得拥有一个 Google的Gson类


Message 类
//规定字段
 type:1
 content:userName
 to:(私聊,群聊)



用户私聊
客户端:

私聊的发起者,主动发送发
1.点击要私聊的用户标签,弹出私聊界面
2.在弹出的页面,按照指定的协议向服务器发送私聊信息
    -type : 2
    -content : sender-msg
    -to:目标客户端的用户名
//.不可能每次点击都new一下私聊界面 所以存在缓存
信息的接收方:
1.判断是私聊或者群聊 , 判断有没有界面 没有就new一个否则取出 弹出私聊界面 ..
2.按照指定协议读取内容,发送信息

服务端:
1.收到客户端发来的私聊信息,取出目标端的Socket, 做信息转发

